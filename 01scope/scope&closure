# 스코프 : 식별자 접근 규칙에 따른 유효 범위
1. 안쪽 스코프에서 바깥쪽 스코프로만 접근 가능
2. 스코프 중첩 가능
3. 전역 스코프 / 지역 스코프로 나뉨
4. 지역 변수는 전역 변수보다 우선 순위 높음

- 블록 스코프 (화살표 함수는 블록 스코프로 취급)
- 함수 스코프 

const 유효범위 : 블록 & 함수 스코프 / 값 재할당 및 재선언 불가
let 유효범위 : 블록 & 함수 스코프 / 값 재할당 가능 & 재선언 불가
var 유효범위 : 함수 스코프 / 값 재할당 및 재선언 가능

# 클로저 함수 : 함수와 함수가 선언된 렉시컬 환경과의 조합 / 어떤 함수가 자기 내부가 아닌 외부에서 선언된 변수에 접근하는 것
렉시컬 환경 : 상위 스코프의 식별자를 포함해 쓰여있는 내부 함수 코드 자체
- 클로저의 핵심 : 스코프 이용해 변수의 접근 범위를 닫는 것 !!!

- 특징 
: 함수가 호출되는 환경과 별개로 기존에 선언된 렉시컬 환경 기준으로 변수 조회함
: 외부 함수 실행 종료 후에도 클로저 함수는 외부 함수의 스코프에 접근 가능
: 외부 함수 스코프는 내부함수에 의해 언제든지 참조 가능
=> 클로저가 많아지면 실행 저하 발생할 수 있음

- 클로저 장점
1. 데이터 보전 가능 => 외부 함수 실행이 끝나도 외부 함수 내 변수 사용할 수 있음
2. 정보의 접근 제한 (캡슐화) => 클로저 모듈 패턴 사용해 여러개의 함수 리턴하도록 만든다
3. 모듈화에 유리 => 클로저 함수를 각각의 변수에 할당하면 각자 독립적으로 값 사용하고 보존해 데이터와 매소드 묶을 수 있어서 함수의 재사용성 극대화

- 클로저 예시
1. 전역에서 선언한 변수를 박스 안에서 함수로 정의하고 전역에서 호출
2. 중첩 함수

#1
var arr = []
for(var i = 0; i < 5; i++){
    arr[i] = function(){
        return i;
    }
}
for(var index in arr) {
    console.log(arr[index]());
} 
=> 5 5 5 5 5

#2 var->let
var arr = []
for(let i = 0; i < 5; i++){
    arr[i] = function(){
        return i;
    }
}
for(var index in arr) {
    console.log(arr[index]());
}
=> 0 1 2 3 4
*** var는 유효범위가 함수 스코프라서 스코프 체인이 console.log가 실행된 함수 내부 -> 상위 함수 내부 이지만
let은 유효범위가 블록 스코프{}라서 console.log가 실행된 중괄호 내부 -> for 루프문의 중괄호 내부로 스코프 체인이 작동하기 때문에
var을 let으로 바꿨을 때 for 루프 내부의 i 값을 콘솔에 출력할 수 있음.

#3 클로저 함수
var arr = []
for(var i = 0; i < 5; i++){
    arr[i] = function(id) {
        return function(){
            return id;
        }
    }(i);
}
for(var index in arr) {
    console.log(arr[index]());
}

=> 0 1 2 3 4
